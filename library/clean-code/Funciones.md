# Clean Code

## üîÄ 2 - Funciones.

### Claridad con el menor esfuerzo.

![C√≥digo limpio](../../static../../static/images/undraw_clean_up.png)

### Para TrainingIT

#### Por Alberto Basalo

<div class="page"/>

# üîÄ 2 - Funciones

## Claridad con el menor esfuerzo.

> _"El buen c√≥digo es su mejor documentaci√≥n."_
>
> -- ‚úçÔ∏è **Steve McConnell**

Permitidme que siga tratando **la programaci√≥n como un tipo concreto de escritura**. Hemos llegado hasta aqu√≠ teniendo un estilo y est√©tica homog√©neos y un vocabulario con sustantivos y verbos para expresar un dominio de conocimiento concreto. Es hora de empezar a escribir.

Y la escritura, ya se trate de blogs, de libros o de programas se basa en organizar palabras en frases. Y estas frases en p√°rrafos. Y despu√©s vendr√°n ya vendr√°n los cap√≠tulos, o los tomos, quiz√°s las series. Pero la unidad es la frase. Que para nosotros ser√°n instrucciones. Aqu√≠ empieza **la claridad y la expresividad**.

Y el conjunto de frases forma los p√°rrafos a los que llamaremos bloques. Muchos de esos bloques se comportar√°n como los p√°rrafos narrativos, aparecer√°n una sola vez. En cambio otros aparecer√°n de manera repetitivas. Y algunos no aparecer√°n a menos que se cumplan ciertas condiciones. Esto es la base de las estructuras repetitivas y condicionales. El lugar d√≥nde los programadores incrustamos **la l√≥gica de negocio**.

¬øQu√© es un cap√≠tulo sin un t√≠tulo? Pues un conjunto de texto que solo cobra sentido al leerlo. En cambio, un buen t√≠tulo te dice mucho sobre lo que pasar√° despu√©s. Te hace ganar inter√©s o te permite dejarlo para otro momento. As√≠ les ocurre a los bloques con nombre: las funciones, subrutinas o m√©todos seg√∫n el lenguaje (idioma) en el que programes (escribas). **Explican lo que hacen las instrucciones.**

Ah se me olvidaba que algunas de estas funciones, adem√°s, son invocadas desde diversos sitios facilitando uno de nuestros principios de limpieza: **evitar la redundancia**.

En las pr√≥ximas entradas de este tutorial prestaremos especial atenci√≥n a las sentencias y a su organizaci√≥n en bloques, estructuras y por √∫ltimo funciones.

> _"A veces, la implementaci√≥n m√°s elegante es solo una funci√≥n. No es un m√©todo. No es una clase. No es un framework. Solo una funci√≥n."_
>
> -- ‚úçÔ∏è **John Carmack**

<div class="page"/>

# üëâ 2.1 - Declaraci√≥n, asignaci√≥n e invocaci√≥n

## Claridad desde el interior.

> _"No soy un gran programador; Solo soy un buen programador con buenos h√°bitos"_
>
> -- ‚úçÔ∏è **Kent Beck**

Los buenos h√°bitos para programar, **la disciplina**, es lo que hace realmente bueno a un programador. Tras el habito de estilizar el c√≥digo y nombrar correctamente variables y funciones, es hora de escribir instrucciones.

Si lo piensas, todas **las instrucciones** que le das a una m√°quina caen en alguna de estas tres categor√≠as: declarar el nacimiento de un variable o funci√≥n; asignar valores a dichos variables o invocar las funciones.

No hay m√°s, ni tampoco menos. As√≠ que dediqu√©mosle unos minutos.

## üë∂ Declaraci√≥n

Independientemente de las diabluras que te permita tu lenguaje (idioma), yo te propongo unas restricciones. Son unos buenos h√°bitos que no te costar√° adquirir.

- Una variable o constante por l√≠nea.

- Primero las constantes.

- Procura inicializar siempre con un valor tus declaraciones de variables.

Ya est√°, no es para tanto. Quiz√° alguno se plantee separar las declaraciones del resto de instrucciones con _una l√≠nea en blanco_. Vale; aunque en funciones peque√±as esto no ser√° tan necesario.

Si la funci√≥n no es peque√±a... deber√≠a serlo.

## üì• Asignaci√≥n

Si has declarado variables es porque tienes pensado asignarles valores din√°micamente. Por ejemplo como resultado del c√°lculo de una expresi√≥n.
Pues bien, una sola norma:

- **Haz que la expresi√≥n sea sencilla.**

¬øQu√© significa sencilla?

- M√°ximo 2 operadores aritm√©ticos o booleanos.
- Usa par√©ntesis para evidenciar el orden de ejecuci√≥n.
- Respeta el largo m√°ximo de l√≠nea.
- Deja espacio alrededor de los operadores para que la expresi√≥n _respire_...

Y ¬øsi el expresi√≥n es mucho m√°s compleja?

- Lleva a **funciones** todo aquello que incumpla lo anterior.

> Acabar√°s con muchas funciones peque√±as... lo s√© y me gusta.

## üìû Invocaci√≥n

As√≠ que en cuanto la cosa se complique... **habr√° que delegar en funciones**, m√©todos, rutinas o como le llam√©is en vuestro idioma.

Y entonces tu instrucci√≥n de asignaci√≥n incluir√° una llamada o invocaci√≥n a ese nuevo m√©todo o funci√≥n.

### üëÆ Atajos a vigilar

Algunos lenguajes facilitan el uso de **operadores condicionales** en medio de expresiones. Pero deben de ser sometidos a las reglas anteriores y estar muy vigilados. Consid√©ralos como _az√∫car sint√°ctico_: es goloso pero da√±ino si abusas.

#### ‚ö†Ô∏è Operadores ternarios

En este caso, el uso del operador ternario se considera como si fuesen dos operadores. Por tanto invalida el anidamiento con otros ternarios o el uso de expresiones complejas en sus ramas de flujo.

- `condition ? value if true : value if false`

#### ‚ö†Ô∏è Operadores l√≥gicos

De nuevo, hay diferencias entre lenguajes. Los operadores _and_ , _or_, _not_ y familia no se representan siempre igual. El caso es que si abusas de notaciones muy concisas puedes estar entorpeciendo la incorporaci√≥n de miembros junior; o dificultando la interpretaci√≥n de una expresi√≥n demasiado _clever_

Intenta evitar loos chequeos en busca nulos. Por ejemplo asignando valores por defecto en los argumentos de las funciones.

- `value = value || defaultValue;`

- `anObject && anObject.doSomething();`

```javascript
// really? wtf!
result = year % 400 === 0 ? true : year % 100 === 0 ? false : year % 4 === 0 ? true : false;
```

En resumen:

> _No encadenes o agrupes estos atajos.
> √ösalos s√≥lo como una abreviaci√≥n de casos muy simples.
> Usa caracter√≠sticas del lenguaje para evitar tratar nulos y valores por defecto._

Considera la posibilidad de **automatizar la detecci√≥n de su incumplimiento** usando alg√∫n tipo de _linter_ o chequeador est√°tico.

<div class="page"/>

# ‚û∞ 2.2 - Estructuras repetitivas y condicionales

## Bloques: Aqu√≠ vive la l√≥gica.

> _"Cada vez que escribas un comentario, debes sentirlo como un fallo de tu capacidad de expresi√≥n"_
>
> -- ‚úçÔ∏è **Robert C. Martin**

Cuando tengo cierta confianza con mis alumnos les suelo realizar una pregunta grosera:

> ¬øProgramas por dinero?

Tras el impacto viene un inc√≥modo silencio para acabar reconociendo lo obvio. Por m√°s que nos guste nuestra profesi√≥n,** la inmensa mayor√≠a de nuestro c√≥digo la hemos escrito a cambio de dinero**; o al menos de su expectativa.

Roto el hielo ya nos sinceramos y reflexionamos acerca de por qu√© otros nos dan su dinero. Y la respuesta suele ser que tienen un problema y nos necesitan para solucionarlo. Suele ser un problema complejo, pues de otra manera buscar√≠an una soluci√≥n menos costosa.

El caso es que **tienen un problema complejo y nosotros debemos resolverlo** programando. Es decir escribiendo en c√≥digo las instrucciones que ejecutar√° un ordenador para satisfacer tu cliente.

Eres un traductor, un intermediario. No lo digo para menospreciar tu trabajo. Es para tomar consciencia de que eres un escritor. Y el lugar en el que mejor se ve esa labor de trasmisi√≥n es en las estructuras condicionales que escribes, y su caso particular de las repeticiones. Es **en estas estructuras d√≥nde realmente reflejas la soluci√≥n al problema** de tu pagador.

## ‚ùì Condicionales

Son los famosos _if_ _else_ _switch_ En tu lenguaje (idioma) puede que se digan de otra forma pero apuesto a que tienen su equivalente.

La recomendaci√≥n para expresar la l√≥gica van de lo simple a lo complejo.

- ‚ö†Ô∏è Si es trivial puedes usar operadores ternarios

- En otro caso utiliza siempre estructuras y envuelve los bloques üîë entre llaves.üóù aunque el lenguaje no te obligue.

- LA condici√≥n de 1Ô∏è‚É£ s√≥lo operador l√≥gico.

- Si la condici√≥n es compleja debe convertirse en una una funci√≥n cuyo nombre comenzar√° por un verbo del estilo _is, has, can should_...

- Favorecer el retorno **anticipado** cuando las condiciones chequean datos err√≥neos o incompletos.

- Favorecer el retorno **unificado.** para la l√≥gica de negocio.

- Evitar los ~~switches~~. Ya veremos c√≥mo.

## ‚ûø Repetitivas

Son un caso particular de condiciones que repiten la ejecuci√≥n de un bloque de instrucciones mientras o hasta que se cumpla una condici√≥n.

De nuevo aplican los mismo criterios:

- LA condici√≥n de ruptura 1Ô∏è‚É£ s√≥lo operador l√≥gico.

- Las variables **locales** deben ser legibles.

- Se permiten los √≠ndices cl√°sicos `i, j`.

## ‚ö†Ô∏è L√≠mites

Los algoritmos que resuelven problemas de negocio, aquellos por los que te pagan, suelen ser complejos. Es muy com√∫n encontrar grupos de las anteriores estructuras juntas para resolver un problema.

La cuesti√≥n es que no pasa nada por encontrar un

```
bucle for

  que dentro lleva otro bucle for
```

Pero ¬øy si dentro necesita un if?

```
bucle for

  que dentro lleva otro bucle for

    el if que se necesita dentro
```

¬øY qu√© ocurre si dentro del if hay switch?

```
  bucle for

    que dentro lleva otro bucle for

        el if que se necesita dentro

          aqu√≠ empieza el switch...
```

Pues ya vemos. El anidamiento de estructuras nos lleva un c√≥digo que cada vez se hace m√°s dif√≠cil de leer.

As√≠ que ese va a ser nuestro primer l√≠mite. M√°ximo dos niveles de anidamiento.

- ‚úÖ1*\_\_2‚ùå \_niveles de anidamiento*

Tampoco es agradable encontrase una estructura, da igual un if que un for, rellena de docenas de l√≠neas. Cuando termina la estructura, te preguntas ¬øa qu√© ven√≠a yo aqu√≠?

As√≠ que ah√≠ te va el segundo l√≠mite: no metas m√°s de 8 l√≠neas dentro de un bloque for o un rama de un if. Idealmente no pases de 4. A partir de ah√≠, crea una funci√≥n e inv√≥cala.

- ‚úÖ4*\_\_8‚ùå \_instrucciones por bloque*

Por √∫ltimo algo que ya dije al principio. Mant√©n simples las condiciones y esconde la complejidad en funciones.

- ‚úÖ1*\_\_2‚ùå \_operadores l√≥gicos por condici√≥n*

Para cumplir estos l√≠mites

> Te obligas a extraer c√≥digo a funciones.

> Te obligas a nombrar las nuevas funciones.

## Consecuencias

- üíº M√°s **reglas de negocio** descritas en las funciones

- üí¨ **Cero** necesidad de comentarios

<div class="page"/>

# üß© 2.3 - Funciones puras y m√©todos de clase

## Peque√±as piezas para organizar programas.

> _"Una funci√≥n deber√≠a hacer una sola cosa, hacerla bien, y hacerla s√≥lo ella."_
>
> -- ‚úçÔ∏è **Ley de Curly**.

Esta frase para enmarcar encierra la verdad esencial de este curso tutorial. **Las funciones son las piezas fundamentales de construcci√≥n de las aplicaciones** limpias. ¬øPor qu√©? Porque son el conjunto m√≠nimo de instrucciones que se le puede asignar un nombre y que se pueden reutilizar.

Es decir, **claridad y reutilizaci√≥n en un mismo artefacto**. Normal que nos inciten a prestarle toda la atenci√≥n, hasta conseguir los tres mandatos:

- **Hacer una sola cosa:** Un √∫nico prop√≥sito especificado en su nombre
- **Hacerla bien\_** Provista de test o al menos con facilidad para la prueba
- **Hacerla s√≥lo ella:** Nombrarla y situarla de forma que no se duplique su cometido accidentalmente

Para conseguirlo podemos desgranar una serie de consejos y l√≠mites aplicables todas nuestras funciones.

## üõ©Ô∏è Peque√±as y Claras

- ‚ôªÔ∏è Cuanto m√°s peque√±as m√°s reutilizables.
- üí™ Con **verbos** en su nombre que indiquen prop√≥sito
- üê´ _DRY_: Don¬¥t Repeat yourself.
- ü•ö con valores por defecto en sus argumentos si el lenguaje los soporta.
- üßê sin condiciones complejas.
- üö© ...sin flags: crea dos variantes con nombre espec√≠fico.
- üí¨ ...sin comentarios. El nombre es el mejor comentario.

## ‚ö†Ô∏è L√≠mites

- ‚úÖ0**\_**0‚ùå _flags_
- ‚úÖ1**\_**2‚ùå _argumentos_
- ‚úÖ8\__\_\_12‚ùå \_complejidad ciclom√°tica_
- ‚úÖ16*\_\_24‚ùå \_instrucciones*

## üíß Favorece el estilo funcional puro:

> _En una **funci√≥n pura** el valor de retorno solo est√° determinado por sus valores de entrada, sin efectos secundarios observables._
>
> -- ‚úçÔ∏è **Alguien a quien le gustan las matem√°ticas**.

_Disclaimer_: Puede que el repentino auge de la programaci√≥n funcional te haga dudar de si esto es una cuesti√≥n de modas. No, no lo es. Los paradigmas de programaci√≥n son cl√°sicos y se deben aplicar consciente y coherentemente. Por supuesto que los lenguajes te predisponen en mayor o menor medida hacia la programaci√≥n funcional, imperativa o la orientada a objetos.

Pero este principio de pureza, obligatorio en programaci√≥n funcional, es la ant√≠tesis de la globalizaci√≥n; y por tanto es una gu√≠a incluso en la programaci√≥n con objetos.

- #### üåô Predecibles.

  - Ante la misma entrada,

  - deben producir la misma salida.

- #### üèû Sin dependencias del entorno.

  - Sus argumentos son su materia prima

  - y su maquinaria.

- #### üöØ Sin efectos secundarios en el entorno.

  - No deben manipular variables externas

  - ni utilizar sistemas externos

Obviamente no todas tus funciones puede ser puras. La idea es que separes unas de otras y favorezcas **que la l√≥gica resida en funciones puras**.

## üì¶ M√©todos en _P.O.O._:

> _En un **m√©todo de clase** deber√≠amos trabajar mucho con el resto de propiedades de la clase y depender poco del exterior._
>
> -- ‚úçÔ∏è **Alguien a quien le gustan la encapsulaci√≥n**.

En el paradigma de **Programaci√≥n Orientada a Objetos**, a la funci√≥n se le llama m√©todo. Y su entorno de trabajo se circunscribe a la clase en la que se define.

Los consejos y l√≠mites recomendados pueden no valer para otros paradigmas y son los siguientes:

- #### 0Ô∏è‚É£ cuantos menos argumentos mejor.

  - üéè evita argumentos _flag_ usando m√∫ltiples funciones espec√≠ficas.

  - favorece objetos en lugar de ~~primitivos~~.

  - los argumentos en m√©todos p√∫blicos son se√±al de dependencia exterior.

- #### 1Ô∏è‚É£ un mismo nivel de abstracci√≥n: delega en funciones privadas

  - las instrucciones en funciones p√∫blicas deber√≠an llamar a funciones privadas.

  - si un m√©todo tiene muchas instrucciones, es que tienen muchas responsabilidades

  - debe delegarlas en otros m√©todos de ayuda

- #### ‚ùé retornando datos; nunca errores.

  - los errores tienen su propio flujo mediante `try-catch throw`.
  - si el lenguaje no lo permitiese, usar convenio en los argumentos
    - como los viejos _callbacks_ `(err, data)`.

## üéØ Objetivo: Muchas Peque√±as Funciones Organizadas

Nuestro reto es conseguir grandes aplicaciones a partir de muchas, much√≠simas, funciones peque√±as. Y para ello es crucial mantener un orden y una organizaci√≥n que permitan **encontrar y no duplicar el conocimiento** que encierran.

- üëÜ Una funci√≥n,

  - ### ü¶Ñ un s√≥lo prop√≥sito.

  - ... o al menos un mismo nivel de abstracci√≥n.

  - claramente definido en su nombre

* üí¨ Sin comentarios.
  - ¬øMe repito?. MAL!!! üòà

> _"Una funci√≥n deber√≠a hacer una sola cosa, hacerla bien, y hacerla s√≥lo ella"_.
>
> -- ‚úçÔ∏è **Ley de Curly**

![Don¬¥t repeat Yourself](../../static../../static/images/dry.jpg)

Como colof√≥n a esta primera parte del curso tutorial te dejo esta m√°xima de _Uncle Bob_. Trata de cumplirla manteniendo las reglas de claridad y modularidad con **muchas funciones peque√±as bien nombradas y organizadas**.

> _"La duplicidad es el principal enemigo de un sistema bien dise√±ado"_
>
> -- ‚úçÔ∏è **Robert C. Martin**
